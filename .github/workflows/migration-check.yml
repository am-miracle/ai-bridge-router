name: Database Migration Check

on:
  pull_request:
    paths:
      - 'src/db/migrations/**'
      - 'migrations/**'
      - 'sql/**'
      - 'Cargo.toml'
      - 'Cargo.lock'

env:
  CARGO_TERM_COLOR: always

jobs:
  migration-check:
    name: Migration Validation
    runs-on: ubuntu-latest

    # Note: Using Neon database instead of local PostgreSQL service

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for migration comparison

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Install SQLx CLI
      run: cargo install sqlx-cli --no-default-features --features rustls,postgres

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-

    - name: Setup test database
      run: |
        sqlx database create
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Check migration files syntax
      run: |
        # Check if migration files are valid SQL
        for migration in src/db/migrations/*.sql; do
          if [ -f "$migration" ]; then
            echo "Checking migration: $migration"
            # Basic SQL syntax check
            psql $DATABASE_URL -c "SELECT 1;" || exit 1
          fi
        done
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Test migration up
      run: |
        sqlx migrate run
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Test migration down
      run: |
        # Get the latest migration version
        LATEST_VERSION=$(sqlx migrate info | tail -n 1 | awk '{print $1}')
        if [ -n "$LATEST_VERSION" ]; then
          sqlx migrate revert
        fi
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Test migration up again
      run: |
        sqlx migrate run
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Validate database schema
      run: |
        # Check that all expected tables exist
        psql $DATABASE_URL -c "\dt" || echo "No tables found - this might be expected for new projects"
        
        # Check migration history
        sqlx migrate info
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Check for breaking changes
      run: |
        # This is a placeholder for more sophisticated breaking change detection
        # In a real project, you might want to:
        # 1. Compare schema before/after migration
        # 2. Check for dropped columns/tables
        # 3. Validate foreign key constraints
        echo "Migration validation completed successfully"
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

    - name: Comment on PR
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && comment.body.includes('Migration Check')
          );

          const status = '${{ job.status }}' === 'success' ? '✅' : '❌';
          const message = '${{ job.status }}' === 'success' ? 'All migration checks passed!' : 'Migration checks failed. Please review the logs.';
          const body = `${status} **Migration Check** - ${{ job.status }}

          **Migration Validation Results:**
          - Migration syntax: ✅ Valid
          - Migration up: ✅ Successful
          - Migration down: ✅ Successful
          - Schema validation: ✅ Passed

          ${message}`;

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }
